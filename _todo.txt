
todo:
 figure out how the compiler is supposed to operate
   project setup and organization
     start creating an "implementation" checklist (unimplemented/incomplete features/guarantees + steps towards implementation)
       organize the checklist in order of what I can do
       adapt this todo list to focus on the checklist
     maybe reorganize the file/project structure
       build up tests in test.yaml
     improve comments within the entire project
       write out spero readme for possible posting
   get basic functional codegen setup and working
     be able to add two integers into a chosen register
     be able to store and use variables
     create, store, and call spero functions
     basic type-checking and inference (set up the pass at least)
      operator -> function translation
   Automatically delete temporary assembly files after compilation
     Add in special command argument to handle this workflow
     Adapt the test runner to use the command when needing to test assembly file
 add in exception/error handling to make the compiler/parser usable
   adapt the compilation state structure to include an error-reporting framework
     figure out what that structure will need
	 make sure to distinguish between errors and warnings
	   setup interface to turn warnings into errors
   hook up the compiler to stop on errors
   improve reporting of the errors (long term project)
     have basic "english" reasoning for the errors and where they occur
 improve performance of the parsing stages
   create benchmark/performance suite for all stages
     improve logging interface/information
	   link stages to information in a usable way
	   improve reporting/collection of timing
	 find a decent way to see the benchmark data
	   hook up reporting to the command line interface
   improve collection and memory usage of location data
   look at using std::string_view instead of std::string everywhere
   look at using attributes in the code
 answer the questions/improvements below
 exhaustively work over the language design to eliminate any issues/oversights
   explore the type system intricately
     consider allowing monomorphic compiler
       also start working on building it up
 start working on more complicated codegen/analysis
 move over to using llvm ir (and libraries)
   switch out x86 codegen for llvm ir (make sure this is a benefit)
   send the rest of the ir over to clang/llvm (need to wait for an update for VS 2017)

 errors:
   "-" is interpreted as a unary way to greedily
     "-" and "2 ++ -" fail to parse
     "-(3, 4)" is a UnaryOp node instead of a FnCall
       this could possibly be resolved in analysis though (maybe in construction)
   possibly add in "error" field for test.compile struct (file to compare compilation errors to)

 organization
   figure out how gcc-assembler interaction will work
     think about renaming speroc so the interaction wrapper can have that name instead
   look at designing a non-graph intermediate representation (returned by analysis stage)

 language questions:
   look into changing rhs operator currying to have same semantics as lhs operator currying
     the major problem is in parsing issues and mitigating them
   figure out how concurrency is going to be handled
     should a yield without a wait equate to a straight return ???
   determine sugaring operations
   figure out the translation of operators fully
     look at scala's handling of '=' for a possible idea
   look into possibly allowing operators to not require parenthesis in indexing
     allow "3.+ 4" instead of "3.+(4)"
       difficult to parse though
   how do unary operators get specialized ???

 parser improvements:
   re-enable "::" syntax for anonymous types
     changed to ":::" due to interference with type inference
     note: 'action<inf>' isn't triggered with "::"
	 could remove the optional tuple (this would allow me to remove the ast_seperator too)
   fncall node may have too much responsibility
   need to determine a distinction between semantic and syntactic typing in the ast
     depends in large part based on how I'm representing types internally
   determine whether I really need the "Future" node
   look into replacing 'std::string' with 'std::string_view' for ast prettyPrint
   look into moving pretty printing into the visitor model
   have the moduleDec rule collect everything as a single string

 prettyPrinting improvements:
   "3 :: Array[Int]" has a wierd output buffering
   annotations could use some improvement

Fix Spero
  Range grammar interfered with sequence grammar on the ',' (step)
  Figure out a better way to handle the duplication between rhs_inher and adt
    The old grammar causes the type name to be pushed on the stack twice
      I fixed this by adding the 'if<at>' rule, but I want to have a more focused rule

Fixes Waiting for Other Features
  In-place modification of containers using for loops/iterators
    Waiting for: Implementation of standard containers and iterators

Breaking Codes