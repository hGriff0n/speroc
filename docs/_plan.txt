Current Project State
  mutability => immutable-by-default
  types =>
	custom: unimplemented
	generics: unimplemented
	inheritance: undetermined (not sure how inheritance will be handled, between Rust 'impl', C++ 'inheritance' or some mix)
    recognized => Int, Bool (literals and comparison operators)
	...
  variables => basic shadowing and scoping
  functions => main-only
  annotations => ignored

Current Project Plan
  Convert all x86 touching code over to using AsmJit
	Perform some more research on AsmJit
	  Figure out how asmjit handles the memory of deleted nodes (don't want memory leaks)
  Get basic type system support up and running
	Doing some basic work with types will be good
	  Compiler Type Representation
	    Improve the basic typing pass a little bit more
		  Connect types to symtable information (maybe preload standard types)
		  Implement "working" type annotations
		    Need a way to go from `ast::Type` to `analysis::Type`
		Add in a couple of regression tests for the typing specification
	  Type Checking
	    Implement an analysis pass to perform basic type checks with arithmetic operators
		  Work on the interfaces to make this process as straightforward as possible
		Start generalization work on the type check algorithm
		Implement path to throw up an error if a variable/values type is not known
		  Because Type Inference won't be implemented, this will cause a lot of programs to fail
		  That's alright for the moment, we'll add that step in later
	  Memory Type Representation
	    Perform experiments/research on how tuples/etc. should be represented in memory
		Determine whether strings should be unicode by default or not
	    Perform experiments/research on how custom types should be represented in memory
		  Decide on the OOP structure for the language
	  Redo the internal structure to have a better integration with the new type system
	    It feels way too haphazard at the moment, I'm attaching stuff with thumb-tacks
		I'll probably make an 'AnalysisState' structure and put all of the stuff in there (for the moment)
		Make sure there's a quick way of getting from a 'Variable' ast node to it's symbol table information
	  Make ".3" produce an error in analysis
	Intermediate Type Work (maybe)
	  Add in assembly instructions specific for floats and booleans
	    Look at generalizing the binopcall assembly generation to account for type differences
	  Add in assembly steps for interacting with tuples
	    Implement AssignTuple assignment rule
		Implement indexing in the case that the indexed type is a tuple (and the index is an int literal)
  Fix grammar and ast properties
    Require directly affixing pointers and references to types
    Allow anon_type to be attached after 'var_val/atom' rules
  Get functions working properly
    I think the current "abort" errors are due to introducing multiple 'main' labels?
	  That wouldn't quite explain the interpreter though
	  Add some special interpreter checks, restrictions and handling
	    Don't allow definition or calling of "main"
    Figure out how to track 'ebp'/etc in order to support the usage of local functions (may be too much for the moment)
	  Fix the issues with 'stack allocation' due to `main` (see `SymTable::setParent`)
	Enable re-entrant evaluation within the interpreter
	  Adapt the compiler data structures to track global definitions across "runs"
	  Add in consideration of global storage location into variable allocations
	    Modify jit-ing code to "reserve" a chunk of memory for storing global variables
		Pass a pointer to this location into the 'AsmGenerator' structure
		  May want to look at generalizing this a bit more (not sure of how well this interacts with compiled binaries)
		Adapt AsmGenerator code to differentiate between global and local variables
	  Modify the general compilation case to enable global variables
	    Figure out how this is done in assembly files
	  Improve the process for "storing" functions across runs
	    We can write the used functions every run, or we can write them once to the global pool (both work)
		  However both have their drawbacks that indicate we probably want to handle functions slightly differently

  Language Logic Checking
    Check if ':<var>' is (and should be) a legal typing
	  Another option is to reserve a keyword (such as "__global__")
	  Adjust the interpreter accordingly (':XX' are commands)
	Look into allowing "def Foo = Foo[Int]" type syntax
	  Reconsider a lot of the grammar for types definition, particularly for specializing generics
    Determine how "Array[Int, a]" would be resolved if a is a global constant (in the context of specialization)
	Figure out contexts to interpret "a :: T" as a type-check and not an annotation
    Figure out what type system I want to support
	  Ensure that it can be type-checked with the algebraic subtyping paper
	  Figure out how generic parameters are introduced/constrained in "impl"
	Flesh out the rules for mutability restrictions
	  Ensure they maintain the semantics I want to have
	Figure out what concurrency systems I want to focus on
    Figure out a way of simplifying mutable methods such as 'get'/'set'
      Find a way to make indexing really trivial (ie. reduce the number of rewrites)
      Thinking is whether I can find a way to cast 'mut' as a monad/HKT parameter
        The guess is you'd then be able to 'map' over it or something like that
	  Find an interface that incourages slices (good range interop)
	Improve documentation, make sure it's up-to-date
	  Write down how function forwarding is going to be determined in lambdas
	    Utilize the same analysis pass that converts `plambda` to function declaration
	Work on language tutorial/introduction

  Convert to using a tri-code IR (ie. max two operands to any instruction)
	Backend stage would take this IR and optimize it to produce the final assembly
	The current 'assembly' stage would be replaced with an IR-generation stage
	  Basically current stage is "AST -> Assembly", we would change to "AST -> IR" + "IR -> Assembly"

  Code Quality Improvements

  Improve error/exception handling and reporting
    Move around logging statements (when combined with push) to reuse location data (see if that makes an improvement first)
	Move 'compiler' exceptions from log-level to error-level
	  Add in 'error indices' and automatic message population capbilities
    Add a better interaction between the ast classes and the logging system
      Improve the logging system while I'm at it (different log outputs, linked/combined loggers, etc.)
	Add in phase timing support using a 'PhaseTimer' style interface (see `compile` for usage)
	Modify the grammar to support unicode in strings
	  Look into allowing unicode in variable names

  Improve "help" support
    Look into adding "code of conduct"

  Basic Function Definition
    Update x86_interpreter/codegen to be able to specify start instruction
	Ensure compiler recognition of function defs and calls works correctly
	Perform codgen of function definitions and ensure they do not interfere with normal compilation
	  These initial functions should just return a value into the 'eax' register
	Add in argument handling/setting for function definitions and calling
	  Might just have a full stack-based solution for now
	  Make sure each "function body" has a 'SymTable' attached to it (for argument setting)
	  Ensure that recursive functions work
	Handle global declarations correctly (ie. place these values in 'separate' memory)
	  Figure out how to handle these separate addressing schemes
	Allow for function bodies to be scopes (with their own local variables)
      Look at possibly modifying the ast to force function wrapping (except possibly in forwarded contexts)
	    Actually, declarations really only make sense (and are somewhat only possible) in functions that already have a scope
	    For all functions, unless a scope is linked by a following block, assume the scope is 'current'
	  TODO: Need to modify 'ebp_offset' setting of the symtable (particularly when accessing "global"/"parent" variables)
        This is accounting for the effects of changing the stack pointers

  Type Inference
    explicit annotations within the ast
  Basic Function Calling
  Custom type definition
  Improve system benchmark collection
  Improve command line interface collection
    Improve the handling of "flags" within the interpreter
  ...
  Converting Operators into function calls [ <- Needs mutability checking and references
  Allow for unicode variable names

  Tester Improvements
    Move to utilizing a directory based test system
	  Test "collections" will be determined by the folder they are in
	    Inside these folders is the yaml specifying expected behavior
		Individual tests may be able to run (ie. only run tests associated with collection.file)
    Have tester produce an output file specifying how many tests have passed
    Integrate this project with Jenkins CI
