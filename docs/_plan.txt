Current Project State
  mutability => immutable-by-default
  types =>
	custom: unimplemented
	generics: unimplemented
	inheritance: undetermined (not sure how inheritance will be handled, between Rust 'impl', C++ 'inheritance' or some mix)
    recognized => Int, Bool (literals and comparison operators)
	...
  variables => basic shadowing and scoping
  functions => main-only
  annotations => ignored

Current Project Plan
  Get function recursion to work properly
	Update all dependencies
  Rearchitect system to have better separation and control flow
    Figure out what I mean by this (what are the current, and future, pain points)
    Add in MIR step and convert assembly codegen to operating off of that
	  Look at generalizing the codegen to enable switching out based on architecture

  Get functions working properly
	Be able to call functions correctly within compiled code
	  Add in the ability to pass in arguments to function calls
	    Integrate function arguments with the VarRef/VarDecl passes
		  Figure out how to get the variables registered in the symbol table
		    Function holds a tuple, which likely holds variable nodes (hard to code a path)
		  Look at creating an 'ArgTuple' node
		Determine what the x86 procedure for the callee and caller when calling a functions
		  Implement the necessary stack frame setup and register saving in the callee side
		    NOTE: May switch out for the CodeCompiler, so this would be unnecessary
    Be able to define multiple functions without triggering compilation errors
	  Generalize the assignment behavior to better follow functions
		Might want to have some basic ability to "sort" everything
		  This is mostly for the interpreter (to simplify wrapping code)
		  It may also make some analysis steps easier
		    If I do this through a dependency graph, then type-checking becomes largely single pass
	  Fix the issue where functions must be declared before they are used (within the global scope)
	Look into how to support local functions/closures
	  Figure out a better way of tracking ebp/etc. so that local variables are accessable
	    This work would mostly be done in terms of the global functions
		  However, I need to consider non-local functions for true generality
	  Figure out where I would have to store the function data in order for it to be usable
	    NOTE: I only need to consider this problem from the widest possible standpoint (any optimizations can be done later)
		  They could be inlined in some cases (if they're never used outside of the function), but starting there would be terrible design
	Enable function usage within the interpreter
	  Generalize the procedure for initializing code to not automatically wrap everything in function
		1) Only wrap global-scope code that is not in a function
		2) Only wrap iff there is such code
	  Allow for defining main within interpreted code
	    To start off, automatically call `main` when it is defined (iff there is no other global code)
	  Allow for defining multiple functions within the interpreter
	    Be able to track where the "entrypoint" is (for both functions)
		Be sure this works with both automatic jumping (to main) and "global" jumping
	  Remove the automatic calling of main (if no global code is provided) within the interpreter
	    Look at producing an error if main is defined (only in the interpreter though)
	Enable re-entrant evaluation within the interpreter
	  Add in the ability to allocate "global" variables into the standard compilation process
	    Figure out how this is done in assembly files
		  NOTE: Be sure to use the "memory location" enum I've already defined
		NOTE: We'll probably need to hard-code in a switch for the assembly generation for the interpreter
		  This should be a temporary thing (eventually)
		  Maybe we could do this based on whether or not the AsmGenerator has a buffer provided to it
	  Add in consideration of global storage location into variable allocations
	    Modify jit-ing code to "reserve" a chunk of memory for storing global variables
		Pass a pointer to this location into the 'AsmGenerator' structure
		  May want to look at generalizing this a bit more (not sure of how well this interacts with compiled binaries)
		Adapt AsmGenerator to utilize this storage space for allocating variables
	  Improve the process for "storing" functions across runs
	    We can write the used functions every run, or we can write them once to the global pool (both work)
		  However both have their drawbacks that indicate we probably want to handle functions slightly differently
    Convert operators to method calls
	  Create a system for harcoding in spero implementations (for now)
	    Eventually this will be replaced by spero code, but that requires asm/IR and modules to be completed first
	  Convert operator calls to being function calls (instead of hardcoded assembly calls)
	  Implement basic type-checking/etc. to automatically select the correct functions based on operand types
	Integrate functions into the type system
	  Figure out how to get function types working as distinct types
	  Add in experimental code to the arguments to allow for restricting based on the type
  Fix grammar and ast properties
    Require directly affixing pointers and references to types
    Allow anon_type to be attached after 'var_val/atom' rules
  Reconsider the implementation of the passes/etc. to provide better generality
    Start from the bottom-up to rework things to have better composability and fewer dependencies
	  Things are starting to get a bit convoluted and I'm not sure about what goes where
	Provide an "allocator" style interface for writing stuff in AsmGenerator
	  This interface would simplify the process of handling the various ways types can be stored in memory
	Look at switching out the CodeBuilder for a CodeCompiler
	  Start working on generalizing based on architecture (allow x86 and x86-64)
  Type Inference and Type Checking
    Read up on the MLsub type inference - see if I can figure out how to implement it
	  Implement a toy algorithm inside of a smaller program (with hardcoded types, etc.)
	  Transfer the toy algorithm over to this program
	Figure out how to load type information into the symbol table
	Intermediate Type Work (maybe)
	  Come up with a quick way to get from a Variable/Binding ast node to it's symbol table information
	    This would be quicker than running the full symbol table query
	  Add in assembly instructions specific for floats and booleans
	    Look at generalizing the binopcall assembly generation to account for type differences
	  Add in assembly steps for interacting with tuples
	    Implement AssignTuple assignment rule
		Implement indexing in the case that the indexed type is a tuple (and the index is an int literal)
		Abstract the assignment rules to simplify the logic
		  For an AssignTuple pattern, split into a series of 'AssignName' (only issue is regarding when scopes come into effect)
  Modules and Imports
  Implement IR lowering phase

  Language Logic Checking
    Check if ':<var>' is (and should be) a legal typing
	  Another option is to reserve a keyword (such as "__global__")
	  Adjust the interpreter accordingly (':XX' are commands)
	Look into allowing "def Foo = Foo[Int]" type syntax
	  Reconsider a lot of the grammar for types definition, particularly for specializing generics
    Determine how "Array[Int, a]" would be resolved if a is a global constant (in the context of specialization)
	Figure out contexts to interpret "a :: T" as a type-check and not an annotation
    Figure out what type system I want to support
	  Ensure that it can be type-checked with the algebraic subtyping paper
	  Figure out how generic parameters are introduced/constrained in "impl"
	Flesh out the rules for mutability restrictions
	  Ensure they maintain the semantics I want to have
	Figure out what concurrency systems I want to focus on
    Figure out a way of simplifying mutable methods such as 'get'/'set'
      Find a way to make indexing really trivial (ie. reduce the number of rewrites)
      Thinking is whether I can find a way to cast 'mut' as a monad/HKT parameter
        The guess is you'd then be able to 'map' over it or something like that
	  Find an interface that incourages slices (good range interop)
	Improve documentation, make sure it's up-to-date
	  Write down how function forwarding is going to be determined in lambdas
	    Utilize the same analysis pass that converts `plambda` to function declaration
	Junction typing syntax sometimes trips up common use cases (`3 :: Int + 4 :: Int` doesn't work)
	Look at re-allowing paren-less functions
	String should be unicode by default
	  I am still undecided about how that should be produced to the users
	    Provide utf-X byte points (ie. strings are arrays)
		Grapheme Clusters (Unicode defined "characters")
		"collation sequential primary element" (apparently a bit more natural "characters")
	  https://manishearth.github.io/blog/2017/01/14/stop-ascribing-meaning-to-unicode-code-points/
	For simplicity sake, I'm going to work off of the initial assumption that types are laid out like in C
	  This assumption may change in the future, particularly to pack, so code should not depend on it
	I'm going full-in on Rust-style impl blocks for adding type inheritance/etc.
	  However, I want to relax the rules a bit (allow for defining traits at junction points, allow for defining traits through "this exists" [free function dispatch (can just do assignment)])
	  I'll also maintain the usage of impl blocks only for inheritance / type fitting
	    You can still define type specific methods inside of the declaration block
	Work on language tutorial/introduction

  Convert to using a tri-code IR (ie. max two operands to any instruction)
	Backend stage would take this IR and optimize it to produce the final assembly
	The current 'assembly' stage would be replaced with an IR-generation stage
	  Basically current stage is "AST -> Assembly", we would change to "AST -> IR" + "IR -> Assembly"

  Code Quality Improvements
    Change the test suit to have a folder-based organization structure
	  Instead of having the yaml file differentiate between the literal and function tests, the directory structure handles that difference
	  Each directory will have a yaml file listing out the expected results of the tests (at that level)
	    If a specific test suite is entered (such as literal.ints) then only the tests in the "literal/ints" folder will be run

  Improve error/exception handling and reporting
    Move around logging statements (when combined with push) to reuse location data (see if that makes an improvement first)
	Move 'compiler' exceptions from log-level to error-level
	  Add in 'error indices' and automatic message population capbilities
    Add a better interaction between the ast classes and the logging system
      Improve the logging system while I'm at it (different log outputs, linked/combined loggers, etc.)
	Add in phase timing support using a 'PhaseTimer' style interface (see `compile` for usage)
	Modify the grammar to support unicode in strings
	  Look into allowing unicode in variable names

  Improve "help" support
    Look into adding "code of conduct"

  Basic Function Definition
    Update x86_interpreter/codegen to be able to specify start instruction
	Ensure compiler recognition of function defs and calls works correctly
	Perform codgen of function definitions and ensure they do not interfere with normal compilation
	  These initial functions should just return a value into the 'eax' register
	Add in argument handling/setting for function definitions and calling
	  Might just have a full stack-based solution for now
	  Make sure each "function body" has a 'SymTable' attached to it (for argument setting)
	  Ensure that recursive functions work
	Handle global declarations correctly (ie. place these values in 'separate' memory)
	  Figure out how to handle these separate addressing schemes
	Allow for function bodies to be scopes (with their own local variables)
      Look at possibly modifying the ast to force function wrapping (except possibly in forwarded contexts)
	    Actually, declarations really only make sense (and are somewhat only possible) in functions that already have a scope
	    For all functions, unless a scope is linked by a following block, assume the scope is 'current'
	  TODO: Need to modify 'ebp_offset' setting of the symtable (particularly when accessing "global"/"parent" variables)
        This is accounting for the effects of changing the stack pointers

  Type Inference
    explicit annotations within the ast
  Basic Function Calling
  Custom type definition
  Improve system benchmark collection
  Improve command line interface collection
    Improve the handling of "flags" within the interpreter
  ...
  Converting Operators into function calls [ <- Needs mutability checking and references
  Allow for unicode variable names

  Tester Improvements
    Move to utilizing a directory based test system
	  Test "collections" will be determined by the folder they are in
	    Inside these folders is the yaml specifying expected behavior
		Individual tests may be able to run (ie. only run tests associated with collection.file)
    Have tester produce an output file specifying how many tests have passed
    Integrate this project with Jenkins CI
