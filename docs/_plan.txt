Current Project State
  mutability => mutable-by-default [off-spec]
  types =>
	custom: unimplemented
	generics: unimplemented
	inheritance: undetermined (not sure how inheritance will be handled, between Rust 'impl', C++ 'inheritance' or some mix)
    recognized => Int, Bool (literals and comparison operators)
	...
  variables => basic shadowing and scoping
  functions => main-only
  annotations => ignored

Current Project Plan
  Convert all x86 touching code over to using AsmJit
	Perform some more research on AsmJit
	  Figure out how asmjit handles the memory of deleted nodes (don't want memory leaks)
	  Add move constructor fixes to wip AsmJit
  Basic Mutability Tracking
	Modify reassignment code to throw out an error when the variable is immutable
	  Change VS Studio options to appropriately format scoped binding
	  Improve the code for interacting with scopes when assigning/accessing variables\
	    Try to remove usage of `SymTable::getParent()` (so I can remove it entirely)
		  Currently used in `visitBlock` and `visitInAssign` as a means of restoring the previous scope
		    InAssign can be done by changing the approach (see comments at function)
		Check if ':<var>' is (and should be) a legal typing (especially for declaration)
		  Adjust the interpreter accordingly (':XX' are commands)
	  Abstract the mutability collection into a separate compiler pass
	    This would probably be the start of a generic "variable" finding pass (ie. type inference, etc)
		  See below for other notes in regard to this phase
		Work on the solidifying and simplifying the process for creating compiler passes
	  Add an SSA name transform pass to handle variable "in-scope" shadowing
	    At every declaration, append the # of times the identifier's been seen so far to the identifier
            NOTE: May be able to "merge" with the symtable collection pass (for now)
		TODO: Also need to keep track of future references and replace those appropriately as well
    Intern strings inside the compiler state structure
	  Add a step in parsing to automatically register any var strings
		Might need to find a better place to locate this (the structure)
	  Try to make this resource allocation generic (abstractable across more resource types)
	Improve 'debuggability' of the 'ast::Path' structure
	  Need to be able to write out the entire string, not just the last symbol
	  Rewrite all path log statements to use the new debug string
	Write in the documentation that compound assignment is not an in-built part of the language
	  At any rate, if the semantics are desirable, the operator overloading system can nominally handle it
	    There are still some issues with typing and binding direction
  Adapt new interpreter to have the capability to have "re-entrant evaluation"
	NOTE: The better part of this step would be in compiler variable tracking
	Convert global variable storage to use a custom "pool" instead of being stack-based
  Fix code base and other issues (see below)
  Get functions working properly
    I think the current "abort" errors are due to introducing multiple 'main' labels?
	  That wouldn't quite explain the interpreter though
	  Add some special interpreter checks, restrictions and handling
	    Don't allow definition or calling of "main"
  Language Logic Checking
    Add in checks to prevent assignments to 'super' and 'self'
	Look into allowing "def Foo = Foo[Int]" type syntax
	  Reconsider a lot of the grammar for types definition, particularly for specializing generics
    Determine how "Array[Int, a]" would be resolved if a is a global constant
	Figure out contexts to interpret "a :: T" as a type-check and not an annotation
    Figure out what type system I want to support
	  Ensure that it can be type-checked with the algebraic subtyping paper
	  Figure out how generic parameters are introduced/constrained in "impl"
	Flesh out the rules for mutability restrictions
	  Ensure they maintain the semantics I want to have
	Figure out what concurrency systems I want to focus on
    Figure out a way of simplifying mutable methods such as 'get'/'set'
      Find a way to make indexing really trivial (ie. reduce the number of rewrites)
      Thinking is whether I can find a way to cast 'mut' as a monad/HKT parameter
        The guess is you'd then be able to 'map' over it or something like that
	Figure out if ".3" should be an error or be an forwarded function
	Figure out a way to apply annotations to tuples
	  Possibly consider not attaching annotations directly at parse time (would allow for "@<var>!" syntax)
	Improve documentation, make sure it's up-to-date
	  Add "accepted change" to require pointer styling to be connected to type name (grammar currently adds a 'ig_s' after)
	  Write down how function forwarding is going to be determined in lambdas
	    Utilize the same analysis pass that converts `plambda` to function declaration
    Add "accepted change" to modify the grammar to allow for 'anon_type' to be attached to `var_val`/`atom` calls (for metaprogramming)
	    Basically remove the requirement to have "Foo() :: {}", instead allow "Foo :: {}"
		NOTE: This should enable easy type creation syntax (look out for possible interactions here too)
	Work on language tutorial/introduction
  Convert to using a tri-code IR (ie. max two operands to any instruction)
	Backend stage would take this IR and optimize it to produce the final assembly
	The current 'assembly' stage would be replaced with an IR-generation stage

  Code Quality Improvements
    Const-correct codebase where possible
	Change function declarations to require arguments to specify their names
	Update to utilize VS 15.5 features where possible (not I'm on 15.4 currently)
	  Switch some std::string applications to use std::string_view
	Simplify the commands available within the repl
	  Also simplify the control path if possible
	  Might want to switch commands to '::' syntax (as ':' may end up being the global scope accessor)

  Convert to clang/llvm backend
	Integrate in the llvm compiler library

  Improve error/exception handling and reporting
    Move around logging statements (when combined with push) to reuse location data (see if that makes an improvement first)
	Move 'compiler' exceptions from log-level to error-level
	  Add in 'error indices' and automatic message population capbilities
    Add a better interaction between the ast classes and the logging system
      Improve the logging system while I'm at it
  Improve "help" support
    Look into adding "code of conduct"

  Basic Types
    Add in tracking of variable/value types within the AST
	  Ensure that 'malformed' expressions can throw up type errors
	Add in handling of explicit annotations for automatically setting the types 
      Ensure these explicit annotations throw up errors on unrecognized types
    Add in unsigned integers, boolean, and float types
	  Extend assembly interpreter with floating point instructions

  Abstract variables collection, etc. into a separate analysis phase
    Rework the visitor system to allow for modification of sub-nodes
	Have new system change VarAssign to Reassign nodes (after collecting relevant information)
	  Ensure this new change interacts correctly with the mutability checking (including with shadowing)
    Change variables from being an entirely push/pop phenomenon (base of off ebp, preallocate stack space)
	  Split out storage of global/static values
	  Also be sure to "track" ebp offsets in a stack based fashion (for supporting local functions)
	Ensure this new system can handle "global" vars being defined post-facto
	  Ensure that we can also force variables to be defined "ahead of time"
	  Adapt 'use before declaration' errors to not be errors in the 'static' & 'type' contexts
	    Might be good to adopt a two-pass system
		  The first pass records all variable declarations and their location
		  The second pass records all variable usages and flags unused/forward-used/created variables
	Rearrange codegen (or modify interpreter) to prevent these systems from interferring with each other (for post-facto variables)
	Look into adding in language for recognizing compound operators
	  A compound operator would map to a reassign<var, operator<var, val>>

  Basic Function Definition
    Update x86_interpreter/codegen to be able to specify start instruction
	Ensure compiler recognition of function defs and calls works correctly
	Perform codgen of function definitions and ensure they do not interfere with normal compilation
	  These initial functions should just return a value into the 'eax' register
	Add in argument handling/setting for function definitions and calling
	  Might just have a full stack-based solution for now
	  Make sure each "function body" has a 'SymTable' attached to it (for argument setting)
	  Ensure that recursive functions work
	Handle global declarations correctly (ie. place these values in 'separate' memory)
	  Figure out how to handle these separate addressing schemes
	Allow for function bodies to be scopes (with their own local variables)
      Look at possibly modifying the ast to force function wrapping (except possibly in forwarded contexts)
	    Actually, declarations really only make sense (and are somewhat only possible) in functions that already have a scope
	    For all functions, unless a scope is linked by a following block, assume the scope is 'current'
	  TODO: Need to modify 'ebp_offset' setting of the symtable (particularly when accessing "global"/"parent" variables)
        This is accounting for the effects of changing the stack pointers

  Type Inference
    explicit annotations within the ast
  Basic Function Calling
  Custom type definition
  Improve system benchmark collection
  Improve command line interface collection
    Improve the handling of "flags" within the interpreter
  ...
  Converting Operators into function calls [ <- Needs mutability checking and references
  Allow for unicode variable names

  Tester Improvements
    Move to utilizing a directory based test system
	  Test "collections" will be determined by the folder they are in
	    Inside these folders is the yaml specifying expected behavior
		Individual tests may be able to run (ie. only run tests associated with collection.file)
    Have tester produce an output file specifying how many tests have passed
    Integrate this project with Jenkins CI


# Note: Can take template+static_assert, or protected+public approaches to restrict allowable combinations