
todo:
 get basic codegen setup and running
   improve the capabilities of the code generation engine
     get proper codegen for returning basic literals (everything but strings)
 rework organization
   think about moving parser back into the speroc main project
   AsmGenerator needs a better placement in the heirarchy
     additionally the AST nodes don't need to be filtered through Visitor
   look at renaming speroc
     this is too facilitate the "forward to gcc" model
   take another look into the ast structure to make sure that every piece is meaningful
 add in exception/error handling to make the compiler usable
   add in a compiler framework for collecting/reporting errors
 improve collection of location data in the compiler (performance)
 setup command line flags for the compiler
   particularly the '-S' flag for getting just the assembly
   change the way the projects are setup
     change the "main" project into a console to query the compiler chain
	 move the "compiler" project internals into a separate project (slightly different name than speroc?)
 setup "test" project
 answer the questions/improvements below

 errors:
   "-" is interpreted as a unary way to greedily
     "-" and "2 ++ -" fail to parse
     "-(3, 4)" is a UnaryOp node instead of a FnCall
       this could possibly be resolved in analysis though (maybe in construction)

 language questions:
   look into changing rhs operator currying to have same semantics as lhs operator currying
     the only problem is in parsing issues and mitigating them
   figure out how concurrency is going to be handled
   should a yield without a wait equate to a straight return ???
   determine sugaring operations
     behavior for '()' operations
       T:apply(A..) -> T(A..)
         I get the name from Scala (might be better to change)
       Indexable[T] -> apply(Size), set(Size, T)
   figure out the translation of operators fully
     especially for '&' and '=', given they have special meanings in some conditions
       maybe make special ast nodes to represent them
       scala handling of '=' at the end (using "l += r")
       if no matching definition "+=" for can be found
         statement translates to "l = +(l, r)"
         otherwise translates to "+=(l, r)"
   change the precedence rules of '&' operators (need to have high precedence)
     might be changing the semantics of pointers so '&' aren't needed
   look into possibly allowing operators to not require parenthesis in indexing
     allow "3.+ 4" instead of "3.+(4)"
       difficult to parse though
   look at solutions for solving the expression problem (typeclasses, multimethods, implicits)

 parser improvements:
   re-enable "::" syntax for anonymous types
     changed to ":::" due to interference with type inference
     note: 'action<inf>' isn't triggered with "::"
	 could remove the optional tuple (this would allow me to remove the ast_seperator too)
   fncall node may have too much responsibility
   maybe change translation of operator calls
     need to check for definitions within the type body first
   need to determine a distinction between semantic and syntactic typing in the ast
     depends in large part based on how I'm representing types internally
   determine whether I really need the "Future" node
   look into replacing 'std::string' with 'std::string_view' for ast prettyPrint
   look into moving pretty printing into the visitor model

 prettyPrinting improvements:
   "3 :: Array[Int]" has a wierd output buffering
   annotations could use some improvement

Fix Spero
  Range grammar interfered with sequence grammar on the ',' (step)
  Figure out a better way to handle the duplication between rhs_inher and adt
    The old grammar causes the type name to be pushed on the stack twice
      I fixed this by adding the 'if<at>' rule, but I want to have a more focused rule
  Figure out the rules and abilities of pointers and manual memory

Fixes Waiting for Other Features
  In-place modification of containers using for loops/iterators
    Waiting for: Implementation of standard containers and iterators

Breaking Codes
	use std:io:println as puts
	def main = () -> {
		#let x = let y = 5 in y * y		# Assignments aren't ValExpr so this breaks
		let x = { let y = 5 in y * y }
		"5^2 = {}".puts(x)
	}